# 実装手法一覧と効果分析

> **目的**: 計画書に含まれる各手法の内容、効果、実装コストを明確化

---

## 手法の全体像

計画には**12の具体的手法**が含まれています。優先度と実装コストで3つのカテゴリに分類：

| カテゴリ | 手法数 | 特徴 |
|----------|--------|------|
| **コア機能**（必須） | 3手法 | セッション継続性・学習の基盤 |
| **開発体験向上**（推奨） | 5手法 | 品質・効率の向上 |
| **拡張機能**（オプション） | 4手法 | 高度な自動化 |

---

## カテゴリ1: コア機能（必須）

### 1. セッションメモリ永続化

**概要**: セッション終了時に状態を保存し、次回開始時に自動読み込み

**構成要素**:
- `SessionStart` hook: 前回セッションファイルを通知
- `Stop` hook: セッションファイルを作成/更新
- `PreCompact` hook: コンパクション前に状態保存

**実装内容**:
```
.claude/
├── hooks/memory-persistence/
│   ├── session-start.sh     # 起動時に前回セッション通知
│   ├── session-end.sh       # 終了時にセッションファイル作成
│   └── pre-compact.sh       # 圧縮前に状態保存
└── sessions/
    └── YYYY-MM-DD-session.tmp  # セッションログ
```

**具体例**:
```
[セッション1: 2026-01-22]
- ユーザー認証機能の実装開始
- validateEmail のテスト作成まで完了
- 次: validatePassword の実装

[セッション2: 2026-01-23 開始時]
→ SessionStart hook が自動通知
  「前回セッション: 2026-01-22-session.tmp
   - validateEmail 完了
   - 次: validatePassword の実装」
```

**効果**:
| 効果 | 詳細 | 定量評価 |
|------|------|----------|
| **セッション再開時間短縮** | 前回の状態を思い出す時間が不要 | 5-10分/日 節約 |
| **コンテキストスイッチ削減** | 複数プロジェクト間の切り替えが容易 | 3-5分/切替 節約 |
| **作業の連続性** | 「何やってたっけ？」が無くなる | ストレス軽減 |

**実装コスト**: 1-2時間（3つのスクリプト作成）

**判断基準**:
- ✅ 1日に複数回セッションを開始する → **必須**
- ✅ 複数プロジェクトを並行作業 → **必須**
- ⚠️ 1セッションで完結する作業のみ → 効果は限定的

---

### 2. 継続学習システム

**概要**: 繰り返し発生するパターンを自動検出し、スキルとして保存

**構成要素**:
- `/learn` コマンド: 手動でパターン抽出
- `evaluate-session.sh` (Stop hook): セッション終了時に自動評価

**実装内容**:
```
.claude/
├── commands/learn.md        # /learn コマンド定義
├── hooks/continuous-learning/
│   ├── evaluate-session.sh  # パターン自動検出
│   └── config.json          # 検出設定
└── skills/learned/          # 学習済みスキル保存先
    ├── error-resolution-websocket-leak.md
    ├── debug-heap-snapshot.md
    └── workaround-library-xyz.md
```

**具体例**:
```
[セッション中に同じエラーを3回解決]

エラー: "WebSocket connection leak"
解決: socket.removeAllListeners('message')

→ /learn 実行
  「このパターンをスキルとして保存しますか？」
  → learned/error-websocket-leak.md に保存

[次回セッションで同じエラー発生]
→ SessionStart hook が通知
  「学習済みスキル: error-websocket-leak.md」
→ Claudeが自動的に解決策を適用
```

**効果**:
| 効果 | 詳細 | 定量評価 |
|------|------|----------|
| **繰り返し作業削減** | 同じ問題を何度も解決しない | 10-30分/問題 節約 |
| **知識の蓄積** | プロジェクト固有の知見が資産化 | 累積効果（長期） |
| **オンボーディング高速化** | 学習スキルを共有可能 | チーム全体で効果 |

**実装コスト**: 2-3時間（コマンド + Stop hook + config）

**判断基準**:
- ✅ 同じエラーを複数回解決している → **必須**
- ✅ プロジェクト固有の回避策が多い → **必須**
- ✅ チームで知見共有したい → **推奨**
- ⚠️ 単発タスクのみ → 効果は限定的

---

### 3. 戦略的コンパクション

**概要**: ツール呼び出し回数をカウントし、論理的なタイミングでcompactを提案

**構成要素**:
- `suggest-compact.sh` (PreToolUse hook): 50回ごとに提案

**実装内容**:
```
.claude/hooks/strategic-compact/
└── suggest-compact.sh

[動作]
ツール呼び出し50回目:
  「💡 50 tool calls reached - consider /compact if transitioning phases」

その後25回ごとに再提案:
  「💡 75 tool calls - checkpoint for /compact if context is stale」
```

**具体例**:
```
[探索フェーズ: 0-50ツール呼び出し]
- コードベース調査
- ファイル検索、Grep実行

→ 50回到達で提案
  「/compact を検討してください（フェーズ移行時）」

ユーザー: /compact 実行

[実装フェーズ: コンテキスト圧縮済み]
- 探索結果のみ残る
- 実装に集中
```

**効果**:
| 効果 | 詳細 | 定量評価 |
|------|------|----------|
| **コンテキスト枯渇防止** | 200k限界に達する前に圧縮 | セッション持続時間 2-3倍 |
| **レスポンス速度向上** | 不要なコンテキストの削減 | レスポンス 10-20% 高速化 |
| **論理的な区切り** | タスク完了→新規開始が明確 | 集中力維持 |

**実装コスト**: 30分（1つのスクリプト）

**判断基準**:
- ✅ 長時間セッション（2時間以上）が多い → **必須**
- ✅ 探索→実装の切り替えが多い → **推奨**
- ⚠️ 短時間セッションのみ → 効果は限定的

---

## カテゴリ2: 開発体験向上（推奨）

### 4. tmux 強制（dev server）

**概要**: 開発サーバーをtmux外で起動しようとするとブロック

**実装内容**:
```json
{
  "matcher": "tool == \"Bash\" && tool_input.command matches \"(npm run dev|pnpm dev)\"",
  "hooks": [{
    "type": "command",
    "command": "echo 'BLOCKED: Dev server must run in tmux' >&2; exit 1"
  }]
}
```

**効果**:
- ✅ ログへのアクセス確保（セッション終了後も確認可能）
- ✅ サーバー再起動の手間削減
- ⚠️ tmux使用が必須になる（学習コスト）

**実装コスト**: 5分（hooks.jsonに追記）

---

### 5. git push 前レビュー

**概要**: `git push` 実行前にエディタを開いて確認を促す

**実装内容**:
```bash
# git push 実行前に一時停止
echo 'Review changes before push...' >&2
read -r  # Enterで継続、Ctrl+Cで中断
```

**効果**:
- ✅ 誤プッシュ防止
- ✅ コミット内容の最終確認
- ⚠️ 毎回確認が必要（頻繁なpushでは煩雑）

**実装コスト**: 5分

---

### 6. console.log 警告

**概要**: ファイル編集後に`console.log`が残っていれば警告

**実装内容**:
```bash
# PostToolUse hook
grep -n "console\.log" "$file_path"
echo "WARNING: console.log found - remove before committing" >&2
```

**効果**:
- ✅ デバッグコードの残存防止
- ✅ プロダクションコード品質向上
- ⚠️ 意図的な`console.log`でも警告（設定で除外可能）

**実装コスト**: 10分

---

### 7. Prettier 自動フォーマット

**概要**: TypeScript/JavaScript編集後に自動フォーマット

**実装内容**:
```bash
# PostToolUse hook
prettier --write "$file_path"
```

**効果**:
- ✅ フォーマット忘れ防止
- ✅ コードスタイル統一
- ⚠️ Prettierが必要（`npm install prettier`）

**実装コスト**: 10分

---

### 8. TypeScript 自動チェック

**概要**: TypeScript編集後に型エラーをチェック

**実装内容**:
```bash
# PostToolUse hook
npx tsc --noEmit | grep "$file_path"
```

**効果**:
- ✅ 型エラーの早期検出
- ✅ ビルドエラー削減
- ⚠️ tscが遅い場合は体感速度低下

**実装コスト**: 15分

---

## カテゴリ3: 拡張機能（オプション）

### 9. 不要な.mdファイル作成ブロック

**概要**: README.md以外のドキュメントファイル作成を防止

**実装内容**:
```bash
if [[ "$file_path" =~ \.(md|txt)$ ]] && [[ ! "$file_path" =~ README ]]; then
  echo "BLOCKED: Use README.md instead" >&2
  exit 1
fi
```

**効果**:
- ✅ ドキュメントの一元化
- ✅ ファイル散乱防止
- ⚠️ 必要なドキュメントも作成不可（除外設定必要）

**実装コスト**: 5分

---

### 10-12. 専門エージェント（9種類）

**概要**: planner, code-reviewer, tdd-guide等の専用サブエージェント

**効果**:
- ✅ タスク特化で品質向上
- ✅ トークン最適化（適切なモデル選択）
- ⚠️ 既存のTask toolで代替可能

**実装コスト**: 1-2時間/エージェント

**判断**: 既存のサブエージェントで十分な場合は不要

---

## 総合評価マトリクス

### コスト vs 効果

```
高効果 ┃
      ┃  ① セッションメモリ
      ┃     永続化
      ┃        ↑
      ┃        │
      ┃  ② 継続学習    ③ 戦略的
      ┃     システム      コンパクション
      ┃        ↑           ↑
中効果 ┃        │           │
      ┃  ④⑤⑥⑦⑧ (開発体験向上)
      ┃     ↑
      ┃     │
      ┃  ⑨⑩⑪⑫ (拡張機能)
低効果 ┃
      ┗━━━━━━━━━━━━━━━━━━━━━━━→
       低コスト    中コスト    高コスト
        (30分)      (2時間)     (5時間+)
```

---

## 推奨実装パターン

### パターンA: ミニマル（初心者向け）

**実装**: コア機能のみ
- ① セッションメモリ永続化
- ③ 戦略的コンパクション

**時間**: 2-3時間
**効果**: セッション継続性の確保、コンテキスト管理

---

### パターンB: スタンダード（推奨）

**実装**: コア + 開発体験向上
- ① セッションメモリ永続化
- ② 継続学習システム
- ③ 戦略的コンパクション
- ⑥ console.log 警告
- ⑦ Prettier 自動フォーマット

**時間**: 4-5時間
**効果**: 上記 + 知識蓄積、コード品質向上

---

### パターンC: フル（上級者向け）

**実装**: すべて
- 全12手法

**時間**: 8-10時間
**効果**: 最大限の自動化と効率化

---

## 実装優先度（個別）

| 優先度 | 手法 | 理由 |
|--------|------|------|
| **🔴 最優先** | ① セッションメモリ | 基盤、効果最大 |
| **🔴 最優先** | ③ 戦略的コンパクション | 長時間セッション必須 |
| **🟡 推奨** | ② 継続学習 | 長期的な効果大 |
| **🟡 推奨** | ⑥ console.log警告 | 品質向上 |
| **🟡 推奨** | ⑦ Prettier | コード統一 |
| **🟢 任意** | ④ tmux強制 | tmux使用者のみ |
| **🟢 任意** | ⑤ git push前レビュー | 慎重派のみ |
| **🟢 任意** | ⑧ TypeScript自動チェック | TSプロジェクトのみ |
| **⚪ オプション** | ⑨-⑫ その他 | 必要に応じて |

---

## 意思決定ガイド

### 質問1: セッションを1日何回開始しますか？

- **3回以上** → パターンB（スタンダード）推奨
- **1-2回** → パターンA（ミニマル）で十分
- **週1回未満** → 実装不要かも

### 質問2: 同じエラーを何度も解決していますか？

- **はい** → 継続学習システム（②）必須
- **いいえ** → 後回しでOK

### 質問3: セッションの長さは？

- **2時間以上** → 戦略的コンパクション（③）必須
- **1時間未満** → 不要

### 質問4: チームで開発していますか？

- **はい** → 継続学習（②） + console.log警告（⑥）推奨
- **いいえ** → 個人の好みで選択

---

## まとめ

**最小構成（2-3時間で実装可能）**:
```
✅ ① セッションメモリ永続化
✅ ③ 戦略的コンパクション
```
→ これだけで「セッション間の継続性」と「長時間作業の安定性」を確保

**推奨構成（4-5時間で実装可能）**:
```
✅ ① セッションメモリ永続化
✅ ② 継続学習システム
✅ ③ 戦略的コンパクション
✅ ⑥ console.log 警告
✅ ⑦ Prettier 自動フォーマット
```
→ 「継続性 + 学習 + 品質」のバランス型

**フル実装は必要に応じて段階的に追加**することを推奨します。
