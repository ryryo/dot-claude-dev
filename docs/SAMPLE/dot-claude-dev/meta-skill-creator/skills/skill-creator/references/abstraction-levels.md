# Abstraction Levels

## 概要

スキル作成における抽象度レベルの定義と、各レベルに応じた対応方法。
抽象度が高いほど、インタビューを通じて具体化する必要がある。

## 3つのレベル

### L1: Concept（概念レベル）

**定義**: アイデアや課題を表現するレベル。「何を解決したいか」が中心。

```
特徴:
- 願望・課題ベースの表現
- 具体的なツールや技術への言及がない
- 「〜したい」「〜を改善したい」のような表現

例:
- 「開発効率を上げたい」
- 「繰り返し作業を減らしたい」
- 「チームの生産性を向上させたい」
- 「ミスを減らしたい」
```

**対応**:
```
1. 課題の深掘り
   「具体的にどの作業に時間がかかっていますか？」
   「どのような問題が発生していますか？」

2. 現状の把握
   「現在はどのように作業を行っていますか？」
   「既存のツールやプロセスはありますか？」

3. 理想の明確化
   「理想的にはどうなっていてほしいですか？」
   「成功の基準は何ですか？」

4. 制約の確認
   「使用できるツールに制限はありますか？」
   「予算や時間の制約はありますか？」
```

### L2: Capability（機能レベル）

**定義**: 機能や能力を表現するレベル。「何をするか」が中心。

```
特徴:
- 機能・能力ベースの表現
- 何をするかは明確だが、どうやるかは不明確
- 「〜を自動化したい」「〜を実行したい」のような表現

例:
- 「PRを自動作成したい」
- 「テストを並列実行したい」
- 「ログを解析してレポートを生成したい」
- 「Slackに通知を送りたい」
```

**対応**:
```
1. トリガーの特定
   「どのようなタイミングで実行しますか？」
   「何がきっかけで処理を開始しますか？」

2. 入出力の明確化
   「入力データは何ですか？」
   「期待する出力は何ですか？」

3. 連携の確認
   「他のシステムとの連携は必要ですか？」
   「既存のワークフローに組み込みますか？」

4. 詳細の確認
   「エラー時の動作はどうしますか？」
   「ログ出力は必要ですか？」
```

### L3: Implementation（実装レベル）

**定義**: 実装の詳細を表現するレベル。「どうやるか」が中心。

```
特徴:
- 実装・詳細ベースの表現
- 具体的なツールや技術への言及がある
- 「〜APIを使って」「〜ライブラリで」のような表現

例:
- 「GitHub APIでPR作成」
- 「Vitestで並列テスト」
- 「Puppeteerでスクレイピング」
- 「Slack Webhook APIで通知」
```

**対応**:
```
1. 技術詳細の確認
   「認証方式は何を使用しますか？」
   「APIのバージョンは？」

2. 実装方針の確認
   「エラーハンドリングの方針は？」
   「リトライ戦略は必要ですか？」

3. 品質要件の確認
   「テストは必要ですか？」
   「ドキュメントは必要ですか？」

4. 運用要件の確認
   「ログレベルは？」
   「監視は必要ですか？」
```

## レベル判定ロジック

### 自動判定基準

```javascript
function detectAbstractionLevel(request) {
  // L3キーワード（具体的な技術/ツール）
  const l3Keywords = [
    'API', 'SDK', 'ライブラリ', 'フレームワーク',
    'GitHub', 'Slack', 'AWS', 'GCP', 'Azure',
    'Node.js', 'Python', 'Bash', 'TypeScript',
    'REST', 'GraphQL', 'WebSocket', 'gRPC'
  ];

  // L2キーワード（機能/アクション）
  const l2Keywords = [
    '自動化', '実行', '生成', '作成', '送信',
    '取得', '変換', '解析', 'デプロイ', 'テスト',
    '通知', '監視', 'バックアップ', '同期'
  ];

  // L1キーワード（願望/課題）
  const l1Keywords = [
    'したい', '改善', '効率', '生産性',
    '減らしたい', '上げたい', '向上', '問題',
    '課題', 'ミス', '時間', 'コスト'
  ];

  if (l3Keywords.some(kw => request.includes(kw))) return 'L3';
  if (l2Keywords.some(kw => request.includes(kw))) return 'L2';
  if (l1Keywords.some(kw => request.includes(kw))) return 'L1';

  return 'L2'; // デフォルト
}
```

### 判定フローチャート

```
[ユーザー要求]
     │
     ▼
具体的な技術/ツールの言及がある?
     │
    Yes ──────► L3: Implementation
     │
    No
     │
     ▼
機能/アクションの言及がある?
     │
    Yes ──────► L2: Capability
     │
    No
     │
     ▼
          L1: Concept
```

## レベル間の移行

### L1 → L2

```
課題から機能への具体化:

L1: 「開発効率を上げたい」
     ↓ ヒアリング
     「どの作業に時間がかかっていますか？」
     「PR作成に毎回30分かかる」
     ↓
L2: 「PRを自動作成したい」
```

### L2 → L3

```
機能から実装への具体化:

L2: 「PRを自動作成したい」
     ↓ ヒアリング
     「どのサービスを使いますか？」
     「GitHub」
     ↓
L3: 「GitHub APIでPR作成」
```

## レベル別スキル設計

### L1向け設計

```
- 柔軟な構成
- 複数の解決策を提示
- ユーザー選択に基づく具体化
- プロトタイプ/MVPアプローチ
```

### L2向け設計

```
- 機能ベースの構成
- 明確な入出力定義
- エラーハンドリング重視
- 拡張性を考慮
```

### L3向け設計

```
- 技術ベースの構成
- 詳細な実装仕様
- テスト重視
- ドキュメント重視
```

## ベストプラクティス

### L1からの開発

```
1. 課題を明確にする
2. 複数の解決策を検討する
3. 最小限のMVPを作成する
4. フィードバックを得て改善する
5. 段階的に機能を追加する
```

### L2からの開発

```
1. 機能要件を整理する
2. 入出力を定義する
3. ワークフローを設計する
4. エラーケースを検討する
5. 実装に進む
```

### L3からの開発

```
1. 技術仕様を確認する
2. APIドキュメントを参照する
3. コード設計を行う
4. テストを作成する
5. 実装を完成させる
```

## アンチパターン

| アンチパターン | 問題点 | 対策 |
|---------------|--------|------|
| L1でいきなり実装 | 課題が不明確なまま作業 | まずヒアリング |
| L3で全体像を無視 | 技術に囚われすぎ | 目的を確認 |
| レベルをスキップ | 重要な情報の欠落 | 段階的に具体化 |
| 確認なしで進行 | 認識齟齬の発生 | 各レベルで確認 |
