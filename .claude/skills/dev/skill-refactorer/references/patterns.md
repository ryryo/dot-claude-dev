# SKILL.md整理パターン集（10パターン）

SKILL.mdを「オーケストレータ（100行未満）」に再構成するための整理パターン。
dev:storyリファクタリング（366行→100行）とdev:*スキル群のコンテキスト効率改善から得た知見を統合。

---

## 1. 圧縮

**問題**: コード例・実例・判定基準・テンプレート等がSKILL.mdを肥大化させる。
**対策**: 詳細を外部ファイルに移し、SKILL.mdは100行未満に。

### チェック項目
- [ ] コード例・実例・サンプル出力 → agents/ or references/
- [ ] 判定基準・分類ロジック → references/
- [ ] テンプレート・出力形式の詳細 → references/templates/
- [ ] 設定例・設定サンプル → references/

---

## 2. DRY化

**問題**: 同じ構造（エージェント呼び出し等）が各ステップで繰り返される。
**対策**: 共通パターンを1回定義し、各ステップでは1行で参照。

### 手法
- 呼び出しパターンをコードブロックで1回定義
- Step/agent/model の対応テーブルを冒頭に配置
- 各ステップでは `→ **Task（model）** に委譲（agents/xxx）` の1行で参照

### チェック項目
- [ ] 同じ構造が3回以上繰り返されていないか
- [ ] 繰り返し構造を冒頭テーブルに集約できないか

---

## 3. LLM行動制御

**問題**: 自然言語で「Taskエージェントで分析」と書いても、LLMが説明文として読んで自分で実行してしまう。
**対策**: 委譲すべき処理には①「自分でやらない」を明示 ②具体的なツール呼び出しコードを提示。

### 手法
- 委譲Stepに `⚠️ ...は必ずTaskエージェントに委譲する。自分で実行しない。` を記載
- `Read(agent.md) → Task(prompt)` の実行パターンをコードブロックで提示
- 各ステップで `→ **Task（model）** に委譲` と太字で強調

### チェック項目
- [ ] 委譲すべき処理に「自分でやらない」旨の明示があるか
- [ ] 具体的なツール呼び出しパターンが提示されているか
- [ ] 自然言語の説明だけで終わっていないか

---

## 4. ゲート条件

**問題**: LLMがステップをスキップしていきなり最終成果物を作成する。
**対策**: 各ステップ末尾にゲート条件を配置。

### 手法
- `**ゲート**: {ファイル}が存在しなければ次に進まない。` を各ステップ末尾に配置
- 中間成果物（JSON等）を必ずファイルとして保存させる

### チェック項目
- [ ] 各ステップに明示的なゲート条件があるか
- [ ] 中間成果物がファイルとして保存される設計か
- [ ] 最終ステップにだけ成果物があり、中間が空になっていないか

---

## 5. 責務分離

**問題**: SKILL.mdにagents/やreferences/側が持つべき詳細が含まれている。
**対策**: SKILL.mdはオーケストレータに徹し、詳細を外部に移す。

### 役割分担
- **SKILL.md**: 「何をどの順でやるか」のみ
- **agents/**: Task委譲時のプロンプト（エージェントがReadして実行する指示書）
- **references/**: メイン実行時の参照情報（判定基準・手順・仕様書）
- **references/templates/**: 新規作成ファイルの雛形（initスクリプトでコピー）
- **scripts/**: ワークスペース初期化・テンプレート配置

### チェック項目
- [ ] SKILL.mdに判定基準・分類ロジック等の詳細が含まれていないか
- [ ] agents/やreferences/側で持つべき情報がSKILL.mdに重複していないか
- [ ] 3行以上のインライン処理がエージェント切り出し候補ではないか

---

## 6. 廃止・整理

**問題**: 使われていない参照や冗長な記述が残っている。
**対策**: 実際に使われているかを確認し、不要なものを削除。

### チェック項目
- [ ] 参照先ファイルが実際に存在するか
- [ ] 参照先ファイルが実際に使われているか（Globで確認）
- [ ] 冗長なコード例（選択肢のJSON例等）がないか
- [ ] 「または〜」で始まる代替パスが実際に使われているか

---

## 7. 構造化

**問題**: SKILL.mdの役割が不明確で、詳細と概要が混在している。
**対策**: SKILL.mdを「オーケストレータ」として位置づけ、構成を統一する。

### 理想構造（100行未満）
```
1. frontmatter（10-20行）
2. 実行ルール定義（0-15行）: スキルの構造に応じて（#8 参照）
3. 出力先（3行）
4. 実行手順（30-40行）: Step + ゲート条件
5. 完了条件（10行）
6. 参照（5行）
```

### チェック項目
- [ ] SKILL.mdが「何をどの順でやるか」に集中しているか
- [ ] 100行未満か
- [ ] 実行手順が最上位に明確に配置されているか

---

## 8. 委譲適切性

**問題**: 全Stepを一律にTask委譲するとコンテキスト断絶が起きる。逆に全Stepをメイン実行するとコンテキストが肥大化する。
**対策**: 各Stepごとにメイン実行/Task委譲の適切性を判定する。

### メイン実行が適切なケース
- 前Stepの出力を直接使う（分析結果→設計書作成など）
- メインコンテキストにある情報（ユーザー入力等）が必要
- references/ の仕様書を参照して成果物を作成する

### Task委譲が適切なケース
- コンテキスト独立（slug生成、フォーマット変換など）
- haiku等の軽量モデルで十分
- 並列実行で高速化できる
- 別視点のチェック（レビュー、検証など）

### SKILL.mdの記述方式（スキル構造に応じて選択）
- **全Stepが委譲** → 冒頭に委譲ルール定義+テーブルが有効（例: dev:developing）
- **メイン/委譲が混在** → 各Stepに実行方式を直接記述（例: dev:epic）

### チェック項目
- [ ] 各Stepの実行方式（メイン/委譲）が明示されているか
- [ ] 前Stepの出力を使うStepがTask委譲になっていないか
- [ ] 独立性の高いStepがメイン実行でコンテキストを圧迫していないか

---

## 9. テンプレート化

**問題**: 新規作成ファイルの構造が仕様書内に散在し、実行時にどこを見ればよいか不明確。
**対策**: テンプレート+initスクリプトで事前配置し、実行時は配置済みファイルを埋める形にする。

### 手法
- `references/templates/` にテンプレートファイルを配置（`*.template.md`）
- `scripts/init-*.sh` でワークスペース作成+テンプレートコピー
- 実行時は `Read（配置済みファイル） → 内容を埋めて Write` で記述

### テンプレート参照の原則
references/内の仕様書で `references/templates/xxx を参照` と書かない。initスクリプトで配置済みのファイルパスを参照する（例: `{dir}/DESIGN.md を Read し、内容を埋めて Write`）。

### チェック項目
- [ ] 新規作成するファイルにテンプレートが用意されているか
- [ ] initスクリプトがテンプレートを配置しているか
- [ ] 仕様書がテンプレートファイルを直接参照していないか（配置済みファイルを参照すべき）

---

## 10. agents/references 配置

**問題**: agents/ と references/ の使い分けが曖昧で、配置が実態と合っていない。
**対策**: ファイルの用途に応じて配置先を判定する。

### 判定フロー
```
そのファイルはTaskエージェントがReadして使う？
  ├─ YES → agents/（委譲プロンプト）
  └─ NO → メイン実行が参照する情報？
            ├─ YES → references/（仕様書・判定基準）
            └─ NO → 新規ファイルの雛形？
                      ├─ YES → references/templates/
                      └─ NO → scripts/ or その他
```

### チェック項目
- [ ] agents/ にメイン参照用の仕様書が混在していないか
- [ ] references/ にTask委譲用のプロンプトが混在していないか
- [ ] テンプレートが references/templates/ に配置されているか
