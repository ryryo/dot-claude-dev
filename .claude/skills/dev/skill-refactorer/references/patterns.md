# SKILL.mdリファクタリング手順

スキルの実行効率・コンテキスト効率を最適化するためのリファクタリング手順。
以下のステップを順に適用する。

---

## Step 1: 各Stepの実行方式を判定する

SKILL.mdの各Stepについて、メイン実行/Task委譲のどちらが適切かを判定する。
これが全体の設計方針を決めるため最初に行う。

### メイン実行にすべきケース
- 前Stepの出力を直接使う（分析結果→設計書作成など）
- メインコンテキストの情報（ユーザー入力等）が必要
- references/ の仕様書を参照して成果物を作成する

### Task委譲にすべきケース
- コンテキスト独立（slug生成、フォーマット変換など）
- haiku等の軽量モデルで十分
- 並列実行で高速化できる
- 別視点のチェック（レビュー、検証など）

### 判定結果に基づくSKILL.mdの記述方式
- **全Stepが委譲** → 冒頭に委譲ルール定義+テーブルを配置（例: dev:developing）
- **メイン/委譲が混在** → 各Stepに実行方式を直接記述（例: dev:epic）

### チェック項目
- [ ] 各Stepの実行方式（メイン/委譲）が明示されているか
- [ ] 前Stepの出力を使うStepがTask委譲になっていないか（コンテキスト断絶）
- [ ] 独立性の高いStepがメイン実行でコンテキストを圧迫していないか

---

## Step 2: ファイル配置を整理する

Step 1 の判定結果に基づき、各外部ファイルの配置先を確定する。

### 配置先の判定フロー
```
そのファイルはTaskエージェントがReadして実行する指示書？
  ├─ YES → agents/
  └─ NO → メイン実行が参照する仕様書・判定基準？
            ├─ YES → references/
            └─ NO → 新規作成ファイルの雛形？
                      ├─ YES → references/templates/
                      └─ NO → scripts/ or その他
```

### よくある修正
- メイン化したStepの指示書が agents/ に残っている → references/ に移動し仕様書化
- 移動時の変換: frontmatter削除、命令形→記述形、エージェント制御ロジック削除、方法論・判定基準は保持

### チェック項目
- [ ] agents/ にメイン参照用の仕様書が混在していないか
- [ ] references/ にTask委譲用のプロンプトが混在していないか
- [ ] テンプレートが references/templates/ に配置されているか

---

## Step 3: SKILL.mdから詳細を分離する

SKILL.mdをオーケストレータ（実行フローの指揮）に集中させ、詳細を外部に移す。

### 分離対象と移動先

| SKILL.md内の記述 | 移動先 |
|------------------|--------|
| 判定基準・分類ロジック | references/ |
| コード例・実例・サンプル出力 | 委譲Stepのもの→agents/、メインStepのもの→references/ |
| 出力ファイルの構造定義 | references/templates/（initスクリプトで配置） |
| 設定例・設定サンプル | references/ |

### テンプレート化
新規作成するファイルがある場合:
1. `references/templates/` にテンプレートファイルを配置（`*.template.md`）
2. `scripts/init-*.sh` でワークスペース作成+テンプレートコピー
3. SKILL.mdやreferences/では配置済みファイルを参照する（`{dir}/DESIGN.md を Read し、内容を埋めて Write`）
4. `references/templates/xxx を参照` とは書かない（initスクリプトの素材であり実行時の参照先ではない）

### チェック項目
- [ ] SKILL.mdに判定基準・分類ロジック等の詳細が残っていないか
- [ ] 新規作成ファイルにテンプレートとinitスクリプトが用意されているか
- [ ] 仕様書がテンプレートファイルを直接参照していないか

---

## Step 4: 繰り返し構造をDRY化する

同じ構造が複数回現れる場合、共通パターンを1回定義して各所から参照する。

### 手法
- 委譲の呼び出しパターンをコードブロックで1回定義
- Step/agent/model の対応テーブルを冒頭に配置
- 各ステップでは `→ **Task（model）** に委譲（agents/xxx）` の1行で参照

### チェック項目
- [ ] 同じ構造が3回以上繰り返されていないか
- [ ] 繰り返し構造を冒頭テーブルに集約できないか

---

## Step 5: LLMの行動を制御する記述にする

LLMが意図通りに動作するよう、曖昧な自然言語を具体的な行動指示に書き換える。

### 委譲Stepの制御
- `→ **Task（model）** に委譲` と太字で明示
- 必要に応じて `⚠️ ...は必ずTaskエージェントに委譲する。自分で実行しない。` を記載
- `Read(agent.md) → Task(prompt)` の実行パターンをコードブロックで提示

### ゲート条件
- 各ステップ末尾に `**ゲート**: {ファイル}が存在しなければ次に進まない。` を配置
- 中間成果物（JSON等）をファイルとして保存させ、スキップを防止

### チェック項目
- [ ] 委譲すべき処理に「自分でやらない」旨の明示があるか
- [ ] 自然言語の説明だけで終わっているStepがないか
- [ ] 各ステップにゲート条件があるか
- [ ] 中間成果物がファイルとして保存される設計か

---

## Step 6: 全体構造を整える

SKILL.mdの構成を統一し、見通しを良くする。

### 理想構造
```
1. frontmatter: name, description, trigger, allowed-tools
2. 実行ルール定義: スキル構造に応じて（全委譲型→テーブル、混在型→省略）
3. 出力先
4. 実行手順: 各Step + ゲート条件
5. 完了条件
6. 参照: 外部ファイル一覧
```

### チェック項目
- [ ] SKILL.mdが「何をどの順でやるか」に集中しているか
- [ ] 実行フローが簡潔で見通しが良いか（目安200行未満）
- [ ] 実行手順がSKILL.mdの中心に配置されているか

---

## Step 7: 不要なものを削除する

最後に、使われていない参照や冗長な記述を整理する。

### チェック項目
- [ ] 参照先ファイルが実際に存在するか
- [ ] 参照先ファイルが実際に使われているか（Globで確認）
- [ ] 冗長なコード例（選択肢のJSON例等）がないか
- [ ] 「または〜」で始まる代替パスが実際に使われているか
- [ ] 移動元に残った空ディレクトリがないか
