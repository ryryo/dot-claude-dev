# TDDワークフロー詳細

## 8ステップワークフロー

```
┌─────────────────────────────────────────────────────────────────┐
│ ステップ1: テストファースト（仕様の固定）                         │
├─────────────────────────────────────────────────────────────────┤
│ 指示: 「TDDでテストだけ書いて。実装は書かない。                   │
│       モック実装も作らない。テスト実行して落ちるのを確認。」       │
│                                                                 │
│ ポイント:                                                        │
│ - 入出力ペアだけを渡す                                           │
│ - test-runner [haiku] でテスト実行 → 失敗を確認                  │
│ - 失敗するテストログを取得 → 仕様が明確化・固定                   │
│ - この段階では実装コードは一切書かない                            │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ ステップ2: テストのコミット                                      │
├─────────────────────────────────────────────────────────────────┤
│ - テストコードをレビュー                                         │
│ - 納得できればテストのみを先行コミット                            │
│ - simple-add-dev [haiku] でコミット実行                              │
│ - 仕様変更を防ぐためテストを先に確定                              │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ ステップ3: 実装の反復（テスト固定）                               │
├─────────────────────────────────────────────────────────────────┤
│ 指示: 「テストは一切変えないで、全部通るまで実装→テストを反復」    │
│                                                                 │
│ プロセス:                                                        │
│ 1. 実装コードを書く                                              │
│ 2. test-runner [haiku] でテスト実行                              │
│ 3. 失敗があれば実装を修正                                        │
│ 4. 全テストが通るまで繰り返す（通常2〜4周で収束）                  │
│                                                                 │
│ ⚠️ 重要: テストは絶対に変更しない（仕様のブレ防止）               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ ステップ4: コード整理（SIMPLIFY）                                │
├─────────────────────────────────────────────────────────────────┤
│ code-simplifierサブエージェント [sonnet] を使用                   │
│                                                                 │
│ 目的:                                                            │
│ - 明瞭性の向上（読みやすさ、理解しやすさ）                         │
│ - 一貫性の確保（コーディングスタイル、パターンの統一）              │
│ - 保守性の向上（変更しやすさ、拡張しやすさ）                       │
│                                                                 │
│ 実行後: test-runner [haiku] でテスト実行し、全テスト通過を確認     │
│                                                                 │
│ 注意: 機能は変更せず、コードの表現のみを改善                       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ ステップ5: セルフレビュー（品質チェック）                         │
├─────────────────────────────────────────────────────────────────┤
│ tdd-reviewサブエージェント [opus] を使用                          │
│                                                                 │
│ 自己検証: 「この実装、テストに過剰適合してない？抜け道ない？」     │
│                                                                 │
│ 確認ポイント:                                                    │
│ - 過剰適合: テストケースだけに最適化されていないか                 │
│ - 抜け道: テストをすり抜ける不具合・エッジケースがないか           │
│ - コードの品質と保守性                                           │
│ - プロジェクト規約への準拠                                       │
│                                                                 │
│ 高度な分析にはopusモデルを使用                                    │
│                                                                 │
│ 問題あり → ステップ3に戻って修正                                  │
│ OKなら → 次のステップへ                                          │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ ステップ6: 品質チェック                                          │
├─────────────────────────────────────────────────────────────────┤
│ quality-checkサブエージェント [haiku] を使用                      │
│                                                                 │
│ 実行内容:                                                        │
│ - Lint: コード品質チェック                                       │
│ - Format: コードフォーマット（自動修正）                          │
│ - Build: ビルド/コンパイル確認                                   │
│                                                                 │
│ エラーがある場合:                                                │
│ - 自動修正可能 → quality-checkが自動修正                         │
│ - 自動修正不可 → ステップ3に戻って実装を調整                      │
│                                                                 │
│ OKなら → 次のステップへ                                          │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ ステップ7: テスト資産の管理                                      │
├─────────────────────────────────────────────────────────────────┤
│ test-asset-managementサブエージェント [sonnet] を使用             │
│                                                                 │
│ テストコードの長期的価値を評価し、適切に管理する                   │
│                                                                 │
│ 判断基準:                                                        │
│ - 長期的な価値がある → テスト資産として保持・維持                  │
│   （回帰テスト、仕様書としての価値、複雑なエッジケース）             │
│ - 一時的な価値のみ → テストを簡素化、または削除を検討              │
│   （実装確認のみのテスト、重複したテストケース）                    │
│                                                                 │
│ 重要: すべてのテストを残す必要はない。                            │
│      開発プロセスでの役割を終えたテストは積極的に整理し、          │
│      メンテナンスコストを最小化する。                              │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ ステップ8: コミット                                              │
├─────────────────────────────────────────────────────────────────┤
│ simple-add-devサブエージェント [haiku] を使用                         │
│                                                                 │
│ 実装とテスト資産管理の結果をコミット                              │
│                                                                 │
│ コミット内容:                                                    │
│ - 実装コード                                                    │
│ - リファクタリング結果                                           │
│ - コード整理結果                                                 │
│ - テスト資産管理の結果（削除・簡素化されたテスト含む）              │
│                                                                 │
│ 軽量・高速なhaikuモデルで効率的にコミット                         │
│                                                                 │
│ 完了 → タスク完了マーク                                          │
└─────────────────────────────────────────────────────────────────┘
```

## TODO.md でのラベル表記

```markdown
- [ ] [TDD][RED] validateEmail のテスト作成
- [ ] [TDD][GREEN] validateEmail の実装
- [ ] [TDD][REFACTOR] validateEmail のリファクタリング
- [ ] [TDD][SIMPLIFY] validateEmail のコード整理
- [ ] [TDD][REVIEW] セルフレビュー
- [ ] [TDD][CHECK] lint/format/build
- [ ] [TDD][MANAGE] テスト資産の管理
- [ ] [TDD][COMMIT] コミット
```

## 設計原則チェックリスト

| カテゴリ | チェック項目 | 確認内容 |
|----------|--------------|----------|
| **SOLID** | 単一責任原則 (SRP) | 1つの関数/モジュールが1つの責務のみ |
| | 依存性逆転原則 (DIP) | 具象ではなく抽象に依存 |
| | インターフェース分離原則 (ISP) | 使わないメソッドへの依存なし |
| **テスタビリティ** | 依存性注入 | 外部から注入可能 |
| | 純粋関数 | 副作用を分離 |
| | グローバル状態 | グローバル変数に依存しない |
| **構造** | 高凝集度 | 関連機能がまとまっている |
| | 低結合度 | モジュール間の依存が最小 |
| | 重複排除 (DRY) | 同じロジックが複数箇所にない |
| **シンプルさ** | YAGNI | 不要な抽象化なし |
| | KISS | 過度な複雑さなし |

## リファクタリングの優先順位

1. テスタビリティの確保（DI、純粋関数化）
2. 単一責任の徹底
3. 重複の排除
4. 命名の改善
